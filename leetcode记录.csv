题号,题目,类型,难度,介绍,思路,第一轮完成情况,第二轮完成情况,题目链接
1,两数之和,哈希表,easy,"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
","哈希表，O(n), O(n)",√,,https://leetcode-cn.com/problems/two-sum/
206,反转链表,链表,easy,反转一个单链表。,"1.迭代：转化成vector再转化回链表  
2.也可以递归",√√,,https://leetcode-cn.com/problems/reverse-linked-list
53,最大子序和,分治法、动态规划,easy,给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。,"1.暴力法：O(n^2), O(1) 
2.动态规划：O(n), O(1) 
3.分治法没看",√,,https://leetcode-cn.com/problems/maximum-subarray
21,合并两个有序链表,链表,easy,将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 ,"直接迭代归并，O(n+m), O(1)",√√,,https://leetcode-cn.com/problems/merge-two-sorted-lists
70,爬楼梯,动态规划,easy,假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？,"动态规划。dp[n] = dp[n-1]+dp[n-2]，O(n), O(n)",√√,,https://leetcode-cn.com/problems/climbing-stairs
20,有效的括号,栈、字符串,easy,给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。,"使用栈读取，当读取到右括号并且栈顶为对应的左括号则弹出，否则压入栈。O(n), O(n)",√√,,https://leetcode-cn.com/problems/valid-parentheses
88,合并两个有序数组,数组、双指针,easy,给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。,"1. 创建新数组直接归并，O(m+n), O(m+n)
2. 双指针法从前往后，先将nums1中m个存起来，把结果存回nums1，空间优化为O(m)
3. 双指针法从后往前，不需要使用额外空间",√,,https://leetcode-cn.com/problems/merge-sorted-array
121,买卖股票的最佳时机,数组、动态规划,easy,"给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。","动态规划，跟53最大子序和很像。O(n), O(1)",√√,,https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock
7,整数反转,数学,easy,给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。,"关键在于检查溢出。转换后的数范围依然要在[-2^31, 2^31-1]之间，也就是[INT_MIN, INT_MAX]",√,,https://leetcode-cn.com/problems/reverse-integer
202,快乐数,哈希表、数学,easy,一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。,"核心在于如何找到循环。
1. 用一个set存储见过的平方和，发生重复时结束。空间占用大。
2. “快慢指针”思想。空间复杂度O(1)",√,,https://leetcode-cn.com/problems/happy-number
204,计数质数,哈希表、数学,easy,统计所有小于非负整数 n 的质数的数量。,"1. 暴力法。但只考虑奇数。
2. 厄拉多塞筛法",√,,https://leetcode-cn.com/problems/count-primes
141,环形链表,,easy,给定一个链表，判断链表中是否有环。,"1. 哈希表, O(n), O(n)
2. 快慢指针 O(n), O(1)",√√,,https://leetcode-cn.com/problems/linked-list-cycle/
118,杨辉三角,数组,easy,"给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
在杨辉三角中，每个数是它左上方和右上方的数的和。
","动态规划，O(n^2), O(n^2)",√√,,https://leetcode-cn.com/problems/pascals-triangle/
234,回文链表,链表、双指针,easy,请判断一个链表是否为回文链表。,"1. 转成vector暴力匹配，O(n), O(n)
2. 快慢指针，反转前半部分链表。O(n), O(1)",√,,https://leetcode-cn.com/problems/palindrome-linked-list/
104,二叉树的最大深度,树、DFS,easy,给定一个二叉树，找出其最大深度。,"1. 递归.DFS, O(n), O(logn)
2. 使用栈做迭代的DFS，O(n), O(n)",√√,,https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/
101,对称二叉树,树、BFS,easy,给定一个二叉树，检查它是否是镜像对称的。,"1. 递归，检测左右子树是否互为镜像。O(n), O(n)
2. 使用队列做迭代，O(n), O(n)，构建两个队列，以相反的顺序插入节点。",×,,https://leetcode-cn.com/problems/symmetric-tree/
155,最小栈,栈、设计,easy,设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。,使用变量或辅助栈存储当前的最小值,√√,,https://leetcode-cn.com/problems/min-stack/
14,最长公共前缀,字符串,easy,编写一个函数来查找字符串数组中的最长公共前缀。,"1. 水平扫描法。先找前两个，前两个再跟第三个找LCS，以此类推。O(S),O(1). S为所有字符数量和。
2. 逐个字符比较，复杂度一样，但是也很慢
3. 分治法，类似归并排序一样。时间复杂度最坏情况下不变，空间O(mlog(n)),
4. 二分查找法，用二分法找到最大长度L，时间O(Slog(n)), 空间O(1)",√,,https://leetcode-cn.com/problems/longest-common-prefix/
136,只出现一次的数字,位运算、哈希表,easy,给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。,"1. 哈希表，O(n), O(n)
2. 位运算，O(n), O(1)。所有的数直接做异或操作",√,,https://leetcode-cn.com/problems/single-number/
198,打家劫舍,动态规划,easy,"你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。","动态规划，currentMax = max(num + prepreMax, preMax); 即每一步都分为抢当前的和不抢当前的两种情况。O(n), O(1)",√√,,https://leetcode-cn.com/problems/house-robber/
69,x的平方根,数学、二分查找,easy,实现 int sqrt(int x) 函数。小数部分舍去,"1. 二分检索,O(logn), O(1)
2. 牛顿法, ",√,,https://leetcode-cn.com/problems/sqrtx/
28,报数,字符串,easy,"报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。
1.     1
2.     11
3.     21
4.     1211
5.     111221",正常循环迭代即可，也可用递归，没什么意义的题，核心就是字符串处理,√√,,https://leetcode-cn.com/problems/count-and-say/
169,求众数,位运算、分治法,easy,给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。,"1. 摩尔投票法：直接设置一个buffer和一个count，如果下个数跟前一个一样则count++，否则--，count为0则更换buffer为当前数。O(n), O(1)
2. 预排序，取中位数。O(nlogn), O(n)
3. 哈希表，O(n), O(n)
4. 分治法，求左右两边的众数",√√,,https://leetcode-cn.com/problems/majority-element/
160,相交链表,链表,easy,编写一个程序，找到两个单链表相交的起始节点。,"双指针法，O(n), O(1)
根据原理 a + all + b = b + all + a
顺序遍历，当a到结尾时从b头开始遍历，对b同理，如果一轮结束两者还没有共同交点，则无交点。",√,,https://leetcode-cn.com/problems/intersection-of-two-linked-lists/
28,实现subStr(),字符串、双指针,easy,判断一个字符串是不是另一个的subString,"1. KMP 算法
2. Sunday算法（未尝试）",√×,,
13,罗马数字转整数,字符串,easy,"需要考虑IV,IX等等",创建一个哈希表，直接检索。第二轮要练习使用c++的哈希表配合字符串操作，熟悉stl，而不是只用if else,√,,https://leetcode-cn.com/problems/roman-to-integer/
344,反转字符串,字符串,easy,"编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。",直接镜像互换就行了，算出目标位置，对应位置直接调换。,√√,,https://leetcode-cn.com/problems/reverse-string/
108,有序数组转化为二叉搜索树,树、DFS,easy,将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。,"1. 直接递归
2. 别的没看",√,,https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
122,买卖股票的最佳时机 II,贪心算法,easy,"给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。",贪心算法，直接逢低买入，逢高卖出即可,√√,,https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
108,将有序数组转换为二叉搜索树,树、DFS,easy,将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。,"1. 递归、或迭代
2. 栈DFS、或队列BFS（第二轮要看一下）",√,,https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/
371,两整数之和,位运算,easy,不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。,先算出不进位的结果，再算出进位的结果,×,,https://leetcode-cn.com/problems/sum-of-two-integers/
26,删除排序数组中的重复项,数组、双指针,easy,给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不适用额外空间,双指针，直接挪就可以了。,√√,,https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/
125,验证回文串,字符串、双指针,easy,给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。,双指针，直接一个头一个尾判断即可，注意用transform()函数先转换为小写，遇到空格跳过即可,√√,,https://leetcode-cn.com/problems/valid-palindrome
237,删除链表中的节点,链表,easy,删除链表中的一个非尾节点的节点，但只给了该节点，而没有头指针。,脑筋急转弯，把下一个node的值复制到当前node，将下一个node删除即可,√√,,https://leetcode-cn.com/problems/delete-node-in-a-linked-list
350,两个数组的交集 II,排序、哈希表、双指针、二分查找,easy,给定两个数组，编写一个函数来计算它们的交集。,"1. 预排序
2. 哈希表，空间换时间",√√,,https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/
387,字符串中的第一个唯一字符,字符串、哈希表,easy,给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。,"直接拿哈希表做就行了，时间O(n), 空间O(n)",√√,,https://leetcode-cn.com/problems/first-unique-character-in-a-string
189,旋转数组,数组,easy,给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。,方法很巧妙，先将数组反转，再将前k个和后n-k个分别反转即可。三次反转操作。时间O(n)，空间O(1),×,,https://leetcode-cn.com/problems/rotate-array
171,Excel表列序号,数学,easy,给定一个Excel表格中的列名称，返回其相应的列序号。,其实就是相当于26进制转10进制,√√,,https://leetcode-cn.com/problems/excel-sheet-column-number/
172,阶乘后的0,数学,easy,给定一个整数 n，返回 n! 结果尾数中零的数量。,数论题，第一次没想到。其实是数含5的因数的数量，而且对25，625..等5的幂要多算一次,×,,https://leetcode-cn.com/problems/factorial-trailing-zeroes/
283,移动零,数组、双指针,easy,给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。,跟前边题号26一样。把后边的数都压缩到前边，最后的空位拿0填上就行了,√√,,https://leetcode-cn.com/problems/move-zeroes/
268,缺失数字,位运算、数组、数学,easy,"给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。",算出理论的和（根据size），再算出实际和，求差就行了。,√×,,https://leetcode-cn.com/problems/missing-number/
271,存在重复元素,数组、哈希表,easy,给定一个整数数组，判断是否存在重复元素。,"直接建哈希表，空间换时间。时间O(n), 空间O(n)",√√,,https://leetcode-cn.com/problems/contains-duplicate/
242,有效字母的异位词,排序、哈希表,easy,给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词(anagram)。,"1. 哈希表，空间换时间,O(n), O(n)
2. 预排序，O(nlogn)，O(1)",√√,,https://leetcode-cn.com/problems/valid-anagram/
66,加一,数组,easy,给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。,关键是判断进位，逢9进一,√√,,https://leetcode-cn.com/problems/plus-one/
190,颠倒二进制位,位运算,easy,颠倒给定的 32 位无符号整数的二进制位。,建一个mask用与运算一位一位的取，把它放到该放的位置即可,√√,,https://leetcode-cn.com/problems/reverse-bits/
191,位1的个数,位运算,easy,编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。,建一个mask用与运算一位一位取就行了,×,,https://leetcode-cn.com/problems/number-of-1-bits/
412,FizzBuzz,,easy,"写一个程序，输出从 1 到 n 数字的字符串表示。
1. 如果 n 是3的倍数，输出“Fizz”；
2. 如果 n 是5的倍数，输出“Buzz”；
3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。",遍历三次，第一次在3的倍数上写Fizz，第二次在5的倍数上写Buzz，最后一次在什么都没有的字符串上写原数字,√√,,https://leetcode-cn.com/problems/fizz-buzz/
326,3的幂,数学,easy,给定一个整数，写一个函数来判断它是否是 3 的幂次方。,"return n > 0 && 1162261467%n == 0;
那个数是int范围里最大的3的幂，只要某数能被其整除则一定是3的幂（等价条件）",×,,https://leetcode-cn.com/problems/power-of-three/
,,,,,,,,
5,最长回文子串,字符串、动态规划,medium,给定一个字符串 s，找到 s 中最长的回文子串,"1. 中心扩展算法。每次从一个字符向左右两边扩张（分奇偶情况），发现左右不相等就停，以获得最长结果，比DP要好。O(n^2), O(1)
2. 动态规划。先找到所有的一字母回文和二字母回文，再找三字母。。以此类推。O(n^2). O(1).",√√,,https://leetcode-cn.com/problems/longest-palindromic-substring/
146,LRU缓存机制,设计,medium,运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。,哈希链表(双链表），利用哈希表的查找时间O(1)和链表插入删除时间为O(1)的特点。在删除节点时一定要注意把哈希表中的节点也删掉。,×,,https://leetcode-cn.com/problems/lru-cache/
3,无重复字符的最长子串,哈希表、双指针,medium,给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。,"1. 暴力法，纯暴力法O(n^3)必超时，如果用哈希表判断是否存在也要O(n^2)。
2. 滑动窗口",√,,https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
300,最长上升子序列,动态规划,medium,给定一个无序的整数数组，找到其中最长上升子序列的长度。,"1. 动态规划。公式：dp[i] = max(dp[j])+1，dp数组中存储从开始到当前数字i并且包括数字i能形成的LIS长度。
2. 动态规划+二分查找。没看",×,,https://leetcode-cn.com/problems/longest-increasing-subsequence
2,两数相加,链表、数学,medium,给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。,关键在于处理逢9会进位的情况,√√,,https://leetcode-cn.com/problems/add-two-numbers/
322,零钱兑换,动态规划,medium,给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。,"直接动态规划即可，从1直到amount，dp[i] = min(dp[coins[0]] + 1, dp[coins[1]] + 1 ….)",√√ ,,https://leetcode-cn.com/problems/coin-change/solution/ling-qian-dui-huan-by-leetcode/
15,三数之和,数组、双指针,medium,"给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
答案中不可以包含重复的三元组。",预排序。之后按顺序每次选一个数，然后再从剩余数里用双指针法选后两个数。本题关键在于如何去重。,×,,https://leetcode-cn.com/problems/3sum/
46,全排列,回溯算法,medium,"给定一个没有重复数字的序列，返回其所有可能的全排列。
",回溯算法,×,,https://leetcode-cn.com/problems/permutations/
179,最大数,排序,medium,给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。结果用字符串表示。,自定义比较函数来进行排序，当ab>ba时a应该放在b之前，反之a放在b之后,√√,,https://leetcode-cn.com/problems/largest-number/
54,螺旋矩阵,数组,medium,"给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。",按层向内循环即可,√√,,https://leetcode-cn.com/problems/spiral-matrix/
378,有序矩阵中第k小的元素,堆、二分查找,medium,"给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
请注意，它是排序后的第k小元素，而不是第k个元素。","1. 直接暴力排序，但是相当于丢失了矩阵原有的顺序信息。O(nlogn)，空间O(n)
2. 二分查找（没懂）
3. n路归并，实现出来比暴力法还慢，其实也丢失了信息
4. 最小堆（没懂）",√,,https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/submissions/
148,排序链表,排序、链表,medium,在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。,自底向上的归并排序，难点在于需要对链表反复断链和拼接。关键在于cut() 和 merge() 两个操作,√,,https://leetcode-cn.com/problems/sort-list/
11,盛水最多的容器,双指针,medium,"给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。","1. 暴力法。可以AC，时间很长。
2. 双指针法。其实就是一种贪心方法，从两侧出发，每次将较短的板向内移动一格。因为向内移动长板必然不会使容积增大，但移动短板可能会使容积增大。",√,,https://leetcode-cn.com/problems/container-with-most-water/
215,数组中第k个最大元素,堆、分治法,medium,在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。,"1. 暴力法。O(nlogn)，O(1)
2. 使用最小堆，每当堆大小大于k，推出当前最小元素，O(nlogk)，空间O(1)
3. 快速选择算法（类似快排），时间平均O(n),空间O(1)",√,,https://leetcode-cn.com/problems/kth-largest-element-in-an-array/
200,岛屿数量,BFS、DFS、并查集,medium,给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。,"1. BFS
2. DFS
3. 并查集",√,,https://leetcode-cn.com/problems/number-of-islands/
91,解码方法,动态规划,medium,"题干略
输入: ""226""
输出: 3
解释: 它可以解码为 ""BZ"" (2 26), ""VF"" (22 6), 或者 ""BBF"" (2 2 6) 。","动态规划。比较容易，公式为dp[i] = dp[i-1]+dp[i-2]，如果s(i)和s(i-1,i)均为合法数字的情况下。需要注意的是当字符串以0开头或中间的某个0前的数大于2，则无法解码。",√√,,https://leetcode-cn.com/problems/decode-ways/
19,删除链表的倒数第N个节点,双指针,medium,"给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
进阶：只使用一趟扫描实现","一趟扫描，双指针，设置dummyhead, 一个指针先走n步，另一个后出发，当第一个指针到了null时，慢指针的next即为要删除的节点。(其实在n之前的每个节点依然被访问了两次，跟两趟遍历差不多，复杂度完全相同，感觉没什么意义）",√,,https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/
33,搜索旋转排序数组,二分查找,medium,"假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。","1. 二分查找直接搜索目标值，其实就是注意划分条件，确定好应该往左找还是往右找。
2. 二分查找寻找旋转轴，然后判断应该在哪个区域做二分查找，思路简单但实现比较麻烦",√√,,https://leetcode-cn.com/problems/search-in-rotated-sorted-array/
279,完全平方数,动态规划,medium,"给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。","这里我只想出了O(n^2)的DP算法，超时。
实际上内层循环只需要考虑完全平方数就行了，所以应为O(nsqrt(n))",× ,,https://leetcode-cn.com/problems/perfect-squares/
56,合并区间,排序、数组,medium,"给出一个区间的集合，请合并所有重叠的区间。
输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。",没什么说的，直接按区间的第一个数排序，再逐个把能合并的合并就行了。,√√,,https://leetcode-cn.com/problems/merge-intervals/
22,括号生成,字符串、回溯算法,medium,给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。,直接回溯算法，剪枝的判断条件为：如果右括号数量大于左括号则剪掉,√√,,https://leetcode-cn.com/problems/generate-parentheses/
240,搜索二维矩阵,二分查找、分治法,medium,"编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
每行的元素从左到右升序排列。
每列的元素从上到下升序排列。","1. 暴力法 O(mn)。忽略了有序信息
2. 二分查找。O(nlgn)，分四块，递归搜索
3. 从角落开始迭代，一步一步挪动，非常巧妙的方法。O(m+n)
选左上角，往右走和往下走都增大，不能选
选右下角，往上走和往左走都减小，不能选
选左下角，往右走增大，往上走减小，可选
选右上角，往下走增大，往左走减小，可选",√ ,,https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
94,二叉树的中序遍历,树、栈,medium,给定一个二叉树，返回它的中序 遍历。,"1. 递归，很简单，先左后中最后右。类似回溯算法
2. 迭代。用栈辅助，每次一直将左节点压入栈中，遍历完当前节点再去遍历右子节点，继续将右子节点的左节点不断压栈",√,,https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
17,电话号码的字母组合,字符串、回溯算法,medium,给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。(参照九宫格键盘）,就是标准的回溯算法、套模板即可,√√,,https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/
236,二叉树的最近公共祖先,树,medium,"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。",递归遍历，使用字典存储每个节点的父指针，并用一个字典存储每个节点的深度。然后双指针从两个节点向上搜即可,√√,,https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/
78,子集,位运算、数组、回溯,medium,给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。,套模板直接回溯就行了。,√√,,https://leetcode-cn.com/problems/subsets/
227,基本计算器II,字符串,medium,实现一个基本的计算器来计算一个简单的字符串表达式的值。,"使用栈、一个存符号，一个存数字
中缀转后缀：
- 数字直接输出到后缀表达式
- 栈为空时，遇到运算符，直接入栈
- 遇到运算符，弹出所有优先级大于或等于该运算符的栈顶元素，并将该运算符入栈
- 合并两个栈，即生成了后缀表达式",√,,https://leetcode-cn.com/problems/basic-calculator-ii/
152,乘积最大子序列,数组、动态规划,medium,给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。,要注意一个负负得正的问题，这里需要存两个dp数组，一个存 当前的最小乘积，一个存当前最大乘积，不断更新到最后即可,√,,https://leetcode-cn.com/problems/maximum-product-subarray/
8,字符串转整数,数学、字符串,medium,请你来实现一个 atoi 函数，使其能将字符串转换成整数。,难点在于处理空格、非字符符号、负号等情况。看着简单写起来麻烦，浪费时间,√√,,https://leetcode-cn.com/problems/string-to-integer-atoi/
55,跳跃游戏,贪心算法、数组,medium,"给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。",就是简单的贪心算法，当遇到0的时候，看0前边的数够不够跳过这些0就行了,√√,,https://leetcode-cn.com/problems/jump-game/
105,从前序和中序遍历中构造二叉树,树、深度优先搜索、数组,medium,如题，树中没有重复元素。,递归实现，有点像分治法、从前序遍历拿到根节点，从中序遍历拿到左子树和右子树，一点一点向下递归即可,√√,,https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
138,复制带随机指针的链表,哈希表、链表,medium,"给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。
要求返回这个链表的深拷贝。 ",两个哈希表、一个是反向的， 存每个节点被哪些节点所指（存下标）。另一个存复制后的每个节点应该指向第几个节点。,√√,,https://leetcode-cn.com/problems/copy-list-with-random-pointer/
240,搜索二维矩阵,二分查找、分治法,medium,"编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
每行的元素从左到右升序排列。
每列的元素从上到下升序排列。","1. 分治法，多路归并，实现起来有些慢，相当于还是丢失了信息。
2. 二分查找？
3. 从右上或左下开始找，不断往固定的方向走，直到找到为止，复杂度O(m+n)，非常巧妙'",√,,https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
79,单词搜索,数组、回溯算法,medium,给定一个二维网格和一个单词，找出该单词是否存在于网格中。,直接套回溯算法模板,√√,,https://leetcode-cn.com/problems/word-search/
102,二叉树的层次遍历,树、广度优先搜索,medium,给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。,"1. 按层遍历，直接用数组存每一层的节点
2. 用队列实现一个BFS，同时要存每个节点的深度",√√,,https://leetcode-cn.com/problems/binary-tree-level-order-traversal/
48,旋转图像,数组,medium,"给定一个 n × n 的二维矩阵表示一个图像。
将图像顺时针旋转 90 度。 必须使用原地算法",一个很巧妙的办法是，先将矩阵转置，再reverse每一行即可。时间复杂度O(n^2),√,,https://leetcode-cn.com/problems/rotate-image/
103,二叉树的锯齿形层次遍历,栈、树、广度优先搜索,medium,给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。,正常按层次遍历，然后输出时一行正一行反就行了,√√,,https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/
208,实现Trie 前缀树,设计、字典树,medium,"实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。","树中的每个节点，TrieNode，都要维护一个字典，<char, TrieNode*>， 来存储所有的子节点",√√ ,,https://leetcode-cn.com/problems/implement-trie-prefix-tree/
139,单词拆分,动态规划,medium,给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。,维护一个dp数组来存储到当前字符为止，能否是一个可拆分的单词，对于每个新来的字母，向前搜索所有dp为true的字符作为断点，看截止到当前字母能否返回一个可拆分的词。时间复杂度O(n^2),√√,,https://leetcode-cn.com/problems/word-break/
347,前k个高频元素,堆、哈希表,medium,给定一个非空的整数数组，返回其中出现频率前 k 高的元素。你的算法的时间复杂度必须优于 O(n log n),"先构建一个<数字, 出现次数>的哈希表。
构建一个优先队列，将哈希表做排序，然后取队列的前k个数字即可",√√,,https://leetcode-cn.com/problems/top-k-frequent-elements/
287,寻找重复数,数组、双指针、二分查找,medium,"给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
要求：原地算法，O(1)空间，时间小于O(nlogn)",这个题的二分查找是要对范围n做二分查找，而不是对原数组。对于1~n范围的数，遍历整个数组，看小于该数的数的数量和大于该数的数的数量是否是理想的，如果不满足条件，则Pivot就是要找的数,√√,,https://leetcode-cn.com/problems/find-the-duplicate-number/
62,不同路径,动态规划,medium,"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。",从左上到右下做动态规划即可，dpMatrix中储存的数字为从起点到该点一共有多少种走法。,√√,,https://leetcode-cn.com/problems/unique-paths/
384,打乱数组,,medium,"打乱一个没有重复元素的数组。
垃圾题，直接拿python写了.","newList = copy.deepcopy(self.originalList)
random.shuffle(newList)",√√,,https://leetcode-cn.com/problems/shuffle-an-array/
395,至少有K个重复字符的最长子串,,medium,找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。,要用递归解法，分治，每次用不可能出现在结果中的字符将字符串分割为两部分或直接n部分，然后对这n部分做递归，即可找到最长结果,√,,https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/
131,分割回文串,回溯算法,medium,给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。要求返回所有的分割方案。,回溯算法。,√√,,https://leetcode-cn.com/problems/palindrome-partitioning/
162,寻找峰值,二分查找,medium,返回数组的任意一个峰值。,二分查找。如果当前数处于上升状态，则往右边找，如果处于下降状态，则往左边找，注意处理头尾的特殊情况即可。,√√,,https://leetcode-cn.com/problems/find-peak-element/
50,"Pow(x, n)",二分查找,medium,"实现pow(x, n)",快速幂算法。根据x^n = x^(n/2) * x^(n/2)，递归也可。,×,,https://leetcode-cn.com/problems/powx-n/
289,生命游戏,数组,medium,看死细胞活细胞的题，状态转换。,原地标记算法，-1记为即将复活，0记为当前死下个状态还死，1记为当前活下个状态继续活，2记为当前活下个状态死。,√,,https://leetcode-cn.com/problems/game-of-life/solution/ren-sheng-ku-duan-de-yuan-di-biao-ji-suan-fa-java0/
34,排序数组中查找某元素的第一个和最后一位置,二分查找,medium,,二分查找的经典题型。分别找到左边界和右边界。这个题很值得多练习,×,,https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/
253,会议室II,堆、排序、贪心,medium,"给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],...] (si < ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。",排序后遍历所有区间，将冲突的单独拎出来继续遍历，直到没有冲突为止。遍历的次数就是需要的会议室的数量。,√√,,https://leetcode-cn.com/problems/meeting-rooms-ii/
207,课程表,拓扑排序,medium,给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？,经典的拓扑排序问题。可以先根据adjList生成adjMatrix，再进行拓扑排序即可。,√,,https://leetcode-cn.com/problems/course-schedule/
130,被围绕的区域,BFS、DFS、并查集,medium,"给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。
找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
被围绕的区间不会存在于边界上",直接用BFS、以所有边界上的O为起点进行BFS，将不需要转换为X的O打上标记，这样其他剩下的O就是跟边界无任何连通的，将剩下的O置为X,√,,https://leetcode-cn.com/problems/surrounded-regions/
328,奇偶链表,链表,medium,给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。,先找到尾部，将尾部链到偶数个节点位置。分奇偶情况讨论。,√√,,https://leetcode-cn.com/problems/odd-even-linked-list/
348,判定井字棋胜负,设计,medium,您有没有可能将每一步的 move() 操作优化到比 O(n2) 更快吗?,每当有人落子后，检查该子对应的横、竖、斜行进行检查,√√,,https://leetcode-cn.com/problems/design-tic-tac-toe/
454,四数相加,哈希表、二分查找,medium,"给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。","1. 将AB中的两两之和存下，将CD中两两之和存下，就转换为了两数之和问题。O(n^2)
2. 二分查找不知道怎么做",√,,https://leetcode-cn.com/problemset/top/?difficulty=%E4%B8%AD%E7%AD%89
134,加油站,贪心算法、数组,medium,给定每一步的收益和开销，判断能否从某一个点出发，走完整一圈。,"1. 暴力算， O(n^2)
2. 一次遍历。从编号0开始，所有站里的油总量>=车子总油耗。如果刚好在k+1站没油，将起点设置为k+1",√,,https://leetcode-cn.com/problems/gas-station/
230,二叉搜索树中第k小的元素,树、二分查找,medium,给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。,中序遍历，中序遍历的输出顺序刚好就是有小到大的,×,,https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/
36,有效的数独,哈希表,medium,检查数独是否有冲突,维护三个哈希表的List，9个行表，9个列表，9个块表，遍历一遍整个矩阵，分别做冲突检查，再检查主从对角线。时间复杂度O(n^2),√,,https://leetcode-cn.com/problems/valid-sudoku/
150,逆波兰表达式,栈,medium,,栈的经典用法。,√√,,https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/
49,字母异位词分组,哈希表,medium,给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。,送分题。直接对每个字符串按字典序排序然后放到哈希表里即可,√√,,https://leetcode-cn.com/problems/group-anagrams/
341,扁平化嵌套列表迭代器,栈、设计,medium,给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。,这里用递归做会简单一些。。用栈稍微麻烦。说是迭代器，但是题解中的人都是在构造迭代器的时候就把所有的数都读取完存到数组里了。,√,,https://leetcode-cn.com/problems/flatten-nested-list-iterator/
238,除自身以外数组的乘积,数组,medium,要求不能使用除法，时间O(n)，空间O(1)，输出数组不视为额外空间,两次遍历，先算每个数左侧的累积，再反向遍历一次算出每个数右侧的累积。,×,,https://leetcode-cn.com/problems/product-of-array-except-self/
75,颜色分类,排序、数组、双指针,medium,"给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
能否想出只用常数空间的一趟扫描法？",直接哈希表存一下不就行？？？,√,,https://leetcode-cn.com/problems/sort-colors/
98,验证二叉搜索树,树、DFS,medium,给定一个二叉树，判断其是否是一个有效的二叉搜索树。,这里不能想当然的认为对每个节点单独判断，root.val > root.left.val && root.val < root.right.val就行了，因为右子树也可能有小于root的数，所以在递归的时候，要跟踪记录该节点应该满足的上界和下界。左子树的上界为root.val，右子树的下界为root.val，任何越界的值都不行,×,,https://leetcode-cn.com/problems/validate-binary-search-tree/
277,搜寻名人,数组,medium,给定一个 邻接表，在尽可能小的时间复杂度基础上，找到一个入度为n-1，出度为0的点。（除了自身不指向自身，其他点都指向它）,"1. 暴力法，对每个点进行一次行遍历和一次列遍历。时间复杂度O(n^2)
2. 贪心。先假设0为名人候选人，遍历其它人i，如果候选人认识i，则修改候选人为i。最后验证候选人是否是名人。
",√,,https://leetcode-cn.com/problems/find-the-celebrity/solution/277-sou-xun-ming-ren-by-guohaoding/
73,矩阵置零,数组,medium,给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。,"1. 可以将即将需要被设置为0的点一个特殊标记（极大或极小的数）但是  对c++很不友好。
2. 将需要设置为0的行或列的行首或者列首置0以作为标记。",√,,https://leetcode-cn.com/problems/set-matrix-zeroes/
380,常数时间插入、删除和获取随机元素,设计、数组、哈希表,medium,,查找时间为O(1)，明显只有哈希表才能实现,√√,,https://leetcode-cn.com/problems/insert-delete-getrandom-o1/
127,单词接龙,BFS,medium,"给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典中的单词。",先存下来哪些词能被转换为哪些词，用作查询字典。然后直接BFS在字典上搜就行了。,√√,,https://leetcode-cn.com/problems/word-ladder/
116,填充每个节点的下一个右侧节点指针,DFS,medium,"给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
","直接递归做了。
对每个节点，连接其左右两个子节点，并连接左子节点的左右子节点，左子节点的右子节点和右子节点的左子节点，右子节点的左右子节点。即可。",√√,,https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/
210,课程表II,拓扑排序,medium,207题为判断题，看能否返回一个拓扑排序。这道题要求返回一个合理的拓扑排序结果，稍加修改即可。,,√√,,https://leetcode-cn.com/problems/course-schedule-ii/
334,递增的三元子序列,,medium,"给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。
要求时间复杂度O(n), 空间O(1)","维护一个大小为3的子序列数组，使子序列尽量小。当前数字为{1, 4}，如果遇到2 ，则更新为{1, 2}； 当前数字为{2, 4}，如果遇到1，则更新为{1,4}，4的存在其实不要紧，会被替换掉的。",×,,https://leetcode-cn.com/problems/increasing-triplet-subsequence/
285,二叉搜索树的顺序后继,树,medium,给你一个二叉搜索树和其中的某一个结点，请你找出该结点在树中顺序后继的节点。,"牢记：二叉搜索树的中序遍历的结果就是其中的元素按大小顺序输出的结果。
此题只要按中序遍历顺序，记录下上一个访问的节点，如果上一个访问的节点就是要找的，那当前节点即为要找的结果。",√√,,https://leetcode-cn.com/problems/inorder-successor-in-bst/
251,展开二维向量,设计,medium,请设计并实现一个能够展开二维向量的迭代器。该迭代器需要支持 next 和 hasNext 两种操作。、,题目341中，题解的人都是直接存，到这里又开始搞正经的迭代器了，扯淡。,√√,,https://leetcode-cn.com/problems/flatten-2d-vector/
114,二叉树展开为链表,树、DFS,medium,给定一个二叉树，原地将它展开为链表。,将右子节点暂存，左子节点拿到右子节点处，递归展开当前的右子节点（原先的左子节点），然后将递归展开后的temp节点（原先的右子节点）接到当前右边的尾巴处，这个尾巴每次都需要从根节点递归向下查找.,√√,,https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/
,,,,,,,,
,,,,,,,,
,,,,,,,,
149,直线上最多的点数,哈希表、数学,hard,给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。,根据点斜式，循环遍历所有的点，对每个点，找到以该点出发，斜率相同的点的数量，存到hashMap里，最后找最大值即可。,√,,https://leetcode-cn.com/problems/max-points-on-a-line/
42,接雨水,栈、数组、双指针,hard,给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。两边不计,"栈的巧妙应用。想起来有点复杂。
1. 按顺序遍历每颗柱子
2. 当前柱子高度小于或等于栈顶柱子高度，把下标压入栈中（为了计算宽度用）
3. 当前柱子高度大于栈顶柱子高度，将栈顶元素弹出，获取其高度，该高度即为洼地的高度，蓄水量=宽*高，这里的高是该洼地两边的最小高度，宽则是两边下标的差值。然后继续循环检查，直到栈空或栈顶柱子高度小于等于当前柱子高度（没有洼地了）",×,,https://leetcode-cn.com/problems/trapping-rain-water/
23,合并K个排序链表,堆、链表、分治法,hard,,"1. 尝试了直接的多路归并，O(Nlogk)
2. 优先队列，也是O(Nlogk)",√,,https://leetcode-cn.com/problems/merge-k-sorted-lists/
124,二叉树中的最大路径和,树、DFS,hard,本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。,"可以直接上递归，递归计算左右两子树能带来的最大收益。
1. 包含当前节点的路径的最大和 = max(根值+左侧最大收益+右侧最大收益， 根值+左侧最大收益，根植+右侧最大收益).  
2. 当前节点能为父节点带去的最大收益 = max(根值， 根值+左侧最大收益，根植+右侧最大收益)",√√,,https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/
140,单词拆分II,动态规划、回溯算法,hard,给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。,"这里先使用139题单词拆分，中的DP算法，算出哪些位置的词与之前的句子可被拆分。然后在DP数组的信息基础上再做回溯。可以AC
但是直接上回溯的话会超时。",√,,https://leetcode-cn.com/problems/word-break-ii/