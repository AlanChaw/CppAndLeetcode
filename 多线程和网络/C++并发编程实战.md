<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [C++并发编程实战笔记](#c%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0)
  - [1. 线程管理](#1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86)
    - [1.1 线程管理基础](#11-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80)
    - [1.2 向线程函数传参](#12-%E5%90%91%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82)
    - [1.3 转移线程所有权](#13-%E8%BD%AC%E7%A7%BB%E7%BA%BF%E7%A8%8B%E6%89%80%E6%9C%89%E6%9D%83)
    - [1.4 运行时决定线程数量](#14-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%B3%E5%AE%9A%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F)
    - [1.5 标识线程](#15-%E6%A0%87%E8%AF%86%E7%BA%BF%E7%A8%8B)
  - [2. 线程间共享数据](#2-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE)
    - [2.1 共享数据带来的问题](#21-%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98)
    - [2.2 使用互斥量保护共享数据](#22-%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE)
    - [2.3 保护共享数据的替代设施](#23-%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9B%BF%E4%BB%A3%E8%AE%BE%E6%96%BD)
  - [4. 同步并发操作](#4-%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C)
    - [4.1 等待一个事件或其他事件](#41-%E7%AD%89%E5%BE%85%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E6%88%96%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6)
    - [4.2 使用期望等待一次性事件](#42-%E4%BD%BF%E7%94%A8%E6%9C%9F%E6%9C%9B%E7%AD%89%E5%BE%85%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BA%8B%E4%BB%B6)
    - [4.3 限定等待时间](#43-%E9%99%90%E5%AE%9A%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4)
    - [4.4 使用同步操作简化代码](#44-%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


# C++并发编程实战笔记

## 1. 线程管理

### 1.1 线程管理基础

1. 线程函数就是线程的入口，main()函数就是初始线程的入口。通常是无参数无返回值的函数。使用 C++ 线程库启动线程，可以归结为构造 `std::thread` 对象：
    ```cpp
    void do_some_work();
    
    std::thread my_thread(do_some_work);
    ```

    与大多数标准库一样，传重载了函数调用运算符（）的类的对象也是可以的：
    ```cpp
    class background_task{
    public:
        void operator()(  ) const{
            do_something();
            do_something_else();
        }
    };

    background_task f;
    std::thread my_thread(f);
    ```
    也可以使用 lambda 表达式（就相当于传一个函数了）：
    ```cpp
    std::thread my_thread([]{
        do_something();
        do_something_else();
    })
    ```

2. 启动线程后，在线程对象被销毁之前，必须决定以何种方式等待线程结束，否则程序就会终止。因此，即使在线程被创建后发生异常，也要确保线程能够正确 join 或 detach。

3. 对于使用 join() 来同步时，要确保在线程对象创建后，join()调用之前，的异常安全性，可以使用 RAII：
    ```cpp
    class thread_guard{
        thread& t;
    public:
        explicit thread_guard(thread& _t)
            : t(_t) {}

        ~thread_guard(){
            if(t.joinable())
                t.join();
        }

        // 禁止拷贝操作
        thread_guard(const thread_guard&) = delete;
        thread_guard& operator=(const thread_guard&) = delete;
    }

    // 当调用线程函数时：
    void f(){
        int local_state = 0;
        thread t(my_func);

        do_some_thing();

        thread_guard g(t);
    }
    ```
    使用 RAII 时，相当于利用了一层 `thread_guard` 做封装，而一旦函数执行过程中，线程 `join()`之前，出现了任何异常，编译器也会自动调用 `thread_guard` 对象 `g` 的析构函数，从而确保线程能够正确加入.


4. 如果选择分离线程(detach)，就必须保证线程结束之前，线程所要访问到的数据都是有效的。例如，当前函数已经退出，函数中局部变量已经被销毁，而线程还没有结束，仍然尝试访问函数中局部变量。要解决这种问题，可以使线程函数功能齐全，将数据都复制到线程中，而非复制到共享数据中（使用一个可接受参数的线程函数）。

5. 如果线程分离，就不能与主线程直接产生交互，主线程也没有 `std::thread` 可以引用该线程。分离线程在后台运行 `joinable() == false`。只有 `joinable() == true` 的时候才可以选择对线程进行 `join()` 或 `detach()` 这种分离线程通常称为 __守护线程(daemon threads)： 没有任何显示的用户接口，并在后台运行的线程__。 


---
### 1.2 向线程函数传参

1. __这里有一个大坑：__ 标准约定 `std::thread` 构造时向函数对象传递实际参数的拷贝（支持移动语义），而不是转发实际参数。即使函数要求接受引用，在构造时传进去的依然是拷贝（这其实是 thread 类构造函数的问题），这种情况在一些编译器是可以通过编译的，但是在函数中修改所谓的引用时，修改的只是线程内部拷贝的引用。这种情况在有些编译环境下根本无法通过编译。所以要求在传引用时，使用 `std::ref()` 函数明确指明传的是引用才可以：

    ```cpp
    void fn(int& a);

    int a = 10;
    std::thread t(fn, std::ref(a));
    t.detach();
    ```
    这样函数 `fn()` 就会真正接收到一个变量 `a` 的引用。

2. 传参时的另一个问题：要注意参数要在传给线程函数前要初始化完成，以满足异常安全性，例如：

    ```cpp
    void f(int i, std::string s);

    std::thread t(f, 3, "hello");
    ```
    这里 "hello" 是作为字面值传入的，会由 `const char*` 被隐式转换成 `string` ，但是这个转换过程中可能会出现异常，所以，需要在调用 `std::thread()` 前就将其转换为 `string` 对象。 这其实与 [Effective C++ 17. 以独立语句将 newed 对象置入智能指针](https://github.com/AlanChaw/Cpp_notes/blob/master/Effective_C%2B%2B.md#17-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86-newed-%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88) 所说的情况是一样的，因为一旦中途出现异常会出问题。

---
### 1.3 转移线程所有权

1. 线程不允许拷贝，但允许移动（发生所有权在实例中的转移）。这一点与 `unique_ptr` 很像。 顺带一提，对这类支持移动但不支持拷贝的对象，可以通过 `std::move` 函数把一个对象移动给另一个空对象，但是不支持移动给另一个非空的对象。
    ```cpp
    using std::thread;
    using std::move;

    t1 = thread(func1);
    // 将 t1 所有权转移给 t2
    thread t2 = move(t1);      
    // 声明一个临时对象 thread(func2)，对于临时对象，会隐式调用移动操作
    t1 = thread(func2);             

    // 将 t2 所有权转移给一个空对象 t3，是可以的
    thread t3;
    t3 = move(t2);
    
    // 将 t3 所有权转移给一个非空对象，会使程序崩溃
    t1 = move(t3);
    ```

2. 支持移动的情况下，也就是说支持其所有权在函数内外进行转移，也就是说
    - 一个 `std::thread` 对象可以作为函数返回值
    - 可以将 `std::thread` 对象作为参数传递给函数

    也就是说，guard_thread 类还可以进行一些改进，即不使用 `std::thread` 指针作为成员，而是直接使用一个对象，这样在构造时直接传入一个线程对象，将这个线程对象的所有权转移给自身成员中的线程对象即可。

---
### 1.4 运行时决定线程数量

1. 函数 `std::thread::hardware_concurrency()` 可以返回能同时并发在一个程序中的线程数量。多核系统中返回的是CPU核心数量。系统信息无法获取时返回0。这个值可以帮助我们动态地、合理地选择开放多少个线程，非常有用。

2. 例子，实现一个并行版本的 `std::accumulate()` 累加器函数。[代码链接](./codes/parallel_accumulate.cpp)  
    - 因为不能从线程中返回一个值（因为对于分离线程，返回值就算有也拿不到，没意义），所以需要传递 results 的引用到线程中。或者通过地址来获取线程执行的结果（_期望（futures）_）

    - 当线程运行时，所有必要的信息都需要传到线程中去，包括存储计算结果的位置。有时候可以传递一个标识数。或者使用线程自身的标识符。

---
### 1.5 标识线程

1. 获取线程标识
    - 可以通过 `std::thread` 的 `get_id()` 来获取当前线程的 id
    
    - 在线程内部，调用：`std::this_thread::get_id()`，也可以获得线程 id

2. 线程 id 常用来检测当前线程是否需要进行一些操作，比如用线程分割工作，主线程可能要做一些与子线程不同的工作。标准库提供了 `std::hash<std::thread::id>` 容器，所以 id 可以用作哈希表的 key.

---
## 2. 线程间共享数据

### 2.1 共享数据带来的问题

1. __不变量（invariants）__：对于特殊结构体的描述。例如双向链表，每个节点有一个指针指向下一个节点，有一个指针指向前一个节点，这就是这个结构体的不变量。但是当操作”删除双向链表中的一个节点“在执行的过程中，这个不变量会被破坏。对于比较复杂的数据结构或一次更新要改动很大的数据结构，不变量更容易被破坏。 一旦一个线程破坏了不变量，此时另一个线程对该数据结构进行修改，会导致错误，这就是：__条件竞争__

2. __条件竞争__： 其形成取决于几个线程相对的执行顺序，每个线程都抢着完成自己的任务，当不变量遭到破坏时，就会产生竞争。例如，并发地去修改一个独立对象，数据竞争是未定义行为的起因。
    - 良性条件竞争：改变顺序也不会影响结果（不变量保持不变）
    - 恶性条件竞争：不变量会遭到破坏

3. 恶性条件竞争通常是时间敏感的，问题复现的几率相当低，只有当系统负载增加时，随着执行数量的增加，执行序列问题的复现才会增加。所以当程序以调试模式运行时，这种错误常常会完全消失。

4. 避免恶性条件竞争
    - 对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态，对于其他线程而言，修改要么已经完成，要么还未开始（相当于事务的隔离性）。
    - 对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分割的变化（无锁编程）。
    - 使用事务的方式去处理数据结构的更新（像数据库系统那样）。所需的数据和读取都存储在事务日志中，将之前的操作合为一步，再进行提交。这称作”软件事务内存“。这种方法C++中没有直接支持。

---
### 2.2 使用互斥量保护共享数据

(这个部分这本书讲的有些乱，感觉这作者本身没什么实际开发经验，需要再找资料学习完善)

1. 当访问共享数据前，使用互斥量将相关数据锁住，当访问结束后将数据解锁。其他线程想要访问加锁数据，都必须等到当前加锁线程将数据解锁后才能访问。 __互斥量__ 是 C++ 中一种最通用的数据保护机制，但互斥量自身也存在一些问题，例如会导致死锁，或对数据保护太多。

2. C++中可以直接使用 `std::mutex` 创建互斥量，调用其 `lock() unlock()` 函数进行加锁和解锁，但是直接调用会破坏异常安全性。所以还可以使用一个  RAII 的模板类 `std::lock_guard`，其会在构造时提供上锁的互斥量，在析构时进行解锁。
    ```cpp
    #include <list>
    #include <mutex>
    #include <algorithm>

    using namespace std;

    list<int> some_list;    // 全局变量
    mutex some_mutex;       // 保护全局变量的互斥量

    void add_to_list(int val){
        // 上锁，使这个函数中对数据的访问是互斥的
        lock_guard<mutex> guard(some_mutex);    
        some_list.push_back(val);
    }

    bool list_contains(int val_to_find){
        // 上锁
        lock_guard<mutex> guard(some_mutex);
        return find(some_list.begin(), some_list.end(), val_to_find);
    }
    ```
    这个只是个例子，多数情况下互斥量会与保护的数据放在同一个类中都作为 private 成员，而不是定义成全局变量。 这里有一个问题在于，当函数返回的是数据的指针或引用时，会破坏对数据的保护，因为函数一旦结束互斥锁就会被销毁，而函数调用者依然可以修改数据。（其实这里直接遵循 [Effective C++ 28. 避免返回指向对象内部成分的句柄](https://github.com/AlanChaw/Cpp_notes/blob/master/Effective_C%2B%2B.md#28-%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9E%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86%E7%9A%84%E5%8F%A5%E6%9F%84) 的要求即可） 

3. 所以，需要精心组织代码来保证线程安全。首先，不仅要保证成员函数不要返回内部对象的指针或引用。而且，也要检查成员函数是否通过指针或引用的方式来调用。再有，将保护数据作为一个运行时参数是更危险的（传递到用户提供的函数指针或函数对象）。总之，要记住一点： __切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数形式传递到用户提供的函数中。__

4. 就算使用了互斥量保护共享数据，依旧需要确定数据受到了保护，需要发现 __接口内在的条件竞争__。 例如对一个类似 `std::stack` 结构的栈，虽然 `empty()` 和 `size()` 在被调用并返回时的结果是正确的，但结果是不可靠的，因为当这些函数返回后，其他线程可以自由访问栈并对栈做修改，这样读取的结果就有问题。 （其实这就是数据库事务的隔离性问题中，幻影读的行为）。例如：
    ```cpp
    stack<int> s;
    if (! s.empty()){                   // 1
        int const value = s.top();      // 2
        s.pop();                        // 3
        do_something(value);
    }
    ```
    这样的代码在单线程下是安全的，但是有可能在读取到栈非空后（1），另一个线程把这个栈掏干了，回到这个线程本身，就再无法正常弹出数据（2，3）。这就是接口固有设计产生的问题。 可以选择把锁的粒度增大，但是这样会导致多线程带来的性能收益明显降低。  
    书中给出了一个解决办法，即：让 `pop()` 函数返回一个指针（`shared_ptr`）指向栈顶元素，另一个重载的 `pop(T& )` 接收一个栈中元素的引用，从而能具体地去删除某个值。

5. __死锁__
    - 当使用多个细粒度锁时，一旦一个给定操作需要两个或两个以上的互斥量，就会发生死锁，这与条件竞争完全相反——不同的两个线程互相等待，什么都没做。

    - 一种方法是控制加锁顺序，都按相同顺序加锁，但是有些时候无法提前预知所有需要用到的锁。而且情况一多，依然无法设计出好的加锁顺序。

    - C++ STL提供了 `std::lock`，允许一次锁住多个互斥量，并且没有死锁风险。例如：
        ```cpp
        #include <mutex>

        class BigObject;
        void swap(BigObject& lhs, BigObject& rhs);
        class X{
        private:
            Bigobject big;
            std::mutex mtx;

        public:
            X(BigObject const& _big)
                : big(_big) {}

            friend void swap(X& lhs, X& rhs){
                if(&lhs == &rhs)    return;

                // 首先锁住两个对象的互斥量
                std::lock(lhs.mtx, rhs.mtx);
                // 使用 RAII lock_guard 将互斥量封装
                // adopt_lock 表示将锁交给 lock_guard 对象管理，不需要创建新锁了
                std::lock_guard<std::mutex> lockA(lhs.m, std::adopt_lock);
                std::lock_guard<std::mutex> lockB(rhs.m, std::adopt_lock);

                swap(lhs.big, rhs.big);
            }
        }
        ```
    虽然 `std::lock` 可以帮助避免死锁，但是不能帮助你只获取其中一个锁（要么都不加锁，要么都加锁）。这就需要程序员的经验来避免死锁了。

6. 死锁进阶
    - __避免嵌套锁__： 一个线程已经获得一个锁时，再别去获取第二个。就算要获取多个锁，也要使用 `std::lock` 来同时上锁。

    - __避免在持有锁时调用用户提供的代码__：因为没有办法确定用户要做什么（例如调用用户传入的函数）。

    - __使用固定顺序获取锁__：当一定要获取两个或以上的锁，并且不能使用 `std::lock` 来同时获取时，要在每个线程上都以固定的顺序来获取。
    - __使用层次锁__：需要对应用进行分层，并且识别在给定层上所有可上锁的互斥量。当试图对一个互斥量上锁时，如果该层锁已被低层持有，是不允许上锁的。
    - 在无锁情况下也会产生死锁，例如每个 `std::thread` 对象调用 `join()`，就会使两个或多个线程互相等待，即产生一个等待循环，从而产生死锁。也可以用分层的办法解决，一个线程只需要等待比自己层级低的线程结束即可。

7. `std::unique_lock`
    - 这种锁更为灵活，其对象以独占所有权的方式管理 mutex 对象的上锁和解锁操作。它具有 `lock_guard` 的功能，且更为灵活，都禁止拷贝，允许移动。
    - `unique_lock` 可以自由控制加锁和解锁（构造时传入 `std::defer_lock` 表明构造时不加锁），但 `lock_guard` 只能在构造时加锁，析构时解锁。 只是开销会多一些，而且允许不带互斥量进行声明。

---
### 2.3 保护共享数据的替代设施

1. 除了互斥量以外，还有其他方法来保护共享数据。例如，为了保护一个数据的初始化过程而使用互斥量是没有必要的。

2. 保护共享数据的初始化
    - 使用双重检查模式加锁对对象进行延迟初始化仍然存在潜在的条件竞争。因此 C++ STL 提供了 `std::once_flag` 和 `std::call_once` 来处理。比起锁住互斥量，并显示地检查对象是否被初始化，每个线程只需使用 `std::call_once`，在其结束时，就能安全地知道对象已经被其他线程初始化了。这种方法比互斥量消耗资源更少。
        ```cpp
        std::shared_ptr<Resource> sptr;
        std::once_flag flag;

        void init_resource(){
            sptr.reset(new Resource);
        }

        void foo(){
            std::call_once(flag, init_resource);

            sptr->do_something(); ...
        }
        ```

3. 保护很少更新的数据结构
    - 对于很少更新的数据结构，只有在写的过程当中需要加锁，在其他时刻的并发读取操作都是线程安全的，如果还使用 `std::mutex` 进行加锁，会削减并发性能，因为读操作也会被上锁，这是不合理的。

    - 使用 __"读写锁"__,这种锁允许两种使用方式：一个”写者“线程独占资源的访问，而多个”读者“允许并发访问。 C++标准库还未支持，可以使用 `boost::shared_mutex` 来做同步。
        - 写操作，使用 `std::unique_lock<boost::shared_mutex>` 上锁，保证该更新线程的独占访问。
        - 读操作，使用 `boost::shared_lock<boost::shared_mutex>` 获取访问权。
        - 当一个线程拥有共享锁，想获取独占锁时，会一直尝试直到当前拥有独占锁的线程释放它的锁（忙等待）；当一个线程拥有独占锁，其他线程无法获取任何锁。

4. 嵌套锁
    - `std::recursive_mutex`，允许多次上锁和多次解锁。例如，当调用 lock() 三次时，也必须调用 unlock() 三次。

    - 嵌套锁一般用在可并发访问的类上，其用互斥量保护其成员数据，每个成员函数都会对互斥量上锁，然后完成对应功能，之后再解锁互斥量。

    - 作者：这种方法不推荐。

---

## 4. 同步并发操作

### 4.1 等待一个事件或其他事件






---
### 4.2 使用期望等待一次性事件




---
### 4.3 限定等待时间



---
### 4.4 使用同步操作简化代码

