# 一些疑难算法

## 二分查找

1. 一般要求时间复杂度为 _logn_ 的题目基本都需要二分查找。
2. 基于 __LeetCode34. 在排序数组中查找元素的第一个和最后一个位置__ 题解  
    详细内容：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/  
    作者：labuladong
    来源：力扣（LeetCode）
3. 例子
    - 最基本的二分查找-寻找一个数
        ```Java
        int binarySearch(int[] nums, int target) {
            int left = 0; 
            int right = nums.length - 1; // 注意

            while(left <= right) {
                int mid = (right + left) / 2;
                if(nums[mid] == target)
                    return mid; 
                else if (nums[mid] < target)
                    left = mid + 1; // 注意
                else if (nums[mid] > target)
                    right = mid - 1; // 注意
                }
            return -1;
        }
        ```
        这里left <= right 的原因是right的初始值是nums.length-1. 这个框架可以保证二分查找的正确性，即：不会漏查也不会溢出. 但是缺陷在于无法找到目标值的左右边界(像Leetocde 34这种情况).  

    - 寻找 __左侧边界__ 的二分查找
        ```Java
        int left_bound(int[] nums, int target) {
            if (nums.length == 0) return -1;
            int left = 0;
            int right = nums.length; // 注意
            
            while (left < right) { // 注意
                int mid = (left + right) / 2;
                if (nums[mid] == target) {  //这里很重要
                    right = mid;
                } else if (nums[mid] < target) {
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    right = mid; // 注意
                }
            }
            return left;
        }
        ```
        - 正确性：此时循环体判断条件为left < right, 因为right初始值为nums.length。搜索区间是[left, right)，左闭右开，所以left = mid + 1; right = mid;   
        - 为什么能找到左边界：这里重要的地方在于当nums[mid] == target时，不返回mid，而是令right = mid;可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。
    
    - 寻找 __右侧边界__ 的二分查找
        ```Java
        int right_bound(int[] nums, int target) {
            if (nums.length == 0) return -1;
            int left = 0, right = nums.length;
            
            while (left < right) {
                int mid = (left + right) / 2;
                if (nums[mid] == target) {
                    left = mid + 1; // 注意
                } else if (nums[mid] < target) {
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    right = mid;
                }
            }
            return right - 1; // 注意
        }
        ```
        - 这里跟寻找左边界不同的是，当 nums[mid] == target 时，left = mid + 1。当找到target时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。
        - 因为收紧左侧边界时必须 left = mid + 1,所以最后无论返回 left 还是 right，必须减一



 <br><br><br>       

---

# 树相关算法

## 二叉树的遍历

1. __深度优先遍历__（通常是所指的是先序遍历）
    - 先序遍历  
        - 顺序：根左右
        - 迭代实现：使用栈，当前节点不为空时，输出该节点值并将其压入栈中，一直使用子循环一直将左子节点压入栈中，直到左子节点为空，再将当前栈顶节点弹出，去访问右子节点。
    - 中序遍历
        - 顺序：左根右
        - 迭代实现：与先序遍历相似，使用栈，唯一区别是使用子循环将左子节点压入栈时，不访问该节点，而是弹出时才访问。
        - tips: 中序遍历二叉搜索树刚好可以将其顺序输出
    - 后序遍历：
        - 顺序：左右根
        - 迭代实现：使用栈，在决定是否可以输出当前节点的值时，需要先判断左右子节点是否被访问过。所以需要设置一个额外的lastVisit游标。若lastVisit等于当前考查节点的右子树（或🈶子树为空），表示该节点的左右子树都已经遍历完成，则可以输出当前节点；否则，需要接着考虑右子树，node = node.right。

2. __广度优先遍历__（层次遍历）
    - 使用队列实现。在队列中加入根节点，如果其左右子节点有不为空的，将根节点出队列，将左右子节点加入队列，以此循环直到队列为空即可。

---
## 堆（优先队列）



---
# 图相关算法

## 拓扑排序  
1. 只能用在有向无环图上(DAG)
2. 原理：每次寻找一个入度为0的节点，访问该节点并删除所有以该节点为起点的有向边。如果剩下的节点中找不到入度为0的节点，说明该图存在环，不是一个DAG.


