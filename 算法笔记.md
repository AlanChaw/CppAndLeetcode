<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [一些疑难算法](#%E4%B8%80%E4%BA%9B%E7%96%91%E9%9A%BE%E7%AE%97%E6%B3%95)
  - [二分查找](#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)
  - [跳舞链](#%E8%B7%B3%E8%88%9E%E9%93%BE)
  - [最大子序和](#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C)
  - [质数计数](#%E8%B4%A8%E6%95%B0%E8%AE%A1%E6%95%B0)
  - [KMP 算法](#kmp-%E7%AE%97%E6%B3%95)
  - [LRU 缓存机制](#lru-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6)
- [树相关算法](#%E6%A0%91%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95)
  - [二叉树的遍历](#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86)
  - [Trie 前缀树](#trie-%E5%89%8D%E7%BC%80%E6%A0%91)
  - [并查集](#%E5%B9%B6%E6%9F%A5%E9%9B%86)
  - [堆（优先队列）](#%E5%A0%86%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97)
  - [<br><br>](#brbr)
- [图相关算法](#%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95)
  - [拓扑排序](#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F)
  - [<br><br>](#brbr-1)
- [数学问题](#%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98)
  - [鸡蛋掉落](#%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD)
  - [可怜的小猪](#%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA)
  - [快速竖式乘法](#%E5%BF%AB%E9%80%9F%E7%AB%96%E5%BC%8F%E4%B9%98%E6%B3%95)
  - [超级次方](#%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9)
  - [到达终点数字](#%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E6%95%B0%E5%AD%97)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


# 一些疑难算法

## 二分查找

1. 一般要求时间复杂度为 _logn_ 的题目基本都需要二分查找。
2. 基于 __LeetCode34. 在排序数组中查找元素的第一个和最后一个位置__ 题解  
    详细内容：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/  
    作者：labuladong
    来源：力扣（LeetCode）
3. 例子
    - 最基本的二分查找-寻找一个数
        ```Java
        int binarySearch(int[] nums, int target) {
            int left = 0; 
            int right = nums.length - 1; // 注意

            while(left <= right) {
                int mid = (right + left) / 2;
                if(nums[mid] == target)
                    return mid; 
                else if (nums[mid] < target)
                    left = mid + 1; // 注意
                else if (nums[mid] > target)
                    right = mid - 1; // 注意
                }
            return -1;
        }
        ```
        这里left <= right 的原因是right的初始值是nums.length-1. 这个框架可以保证二分查找的正确性，即：不会漏查也不会溢出. 但是缺陷在于无法找到目标值的左右边界(像Leetocde 34这种情况).  

    - 寻找 __左侧边界__ 的二分查找
        ```Java
        int left_bound(int[] nums, int target) {
            if (nums.length == 0) return -1;
            int left = 0;
            int right = nums.length; // 注意
            
            while (left < right) { // 注意
                int mid = (left + right) / 2;
                if (nums[mid] == target) {  //这里很重要
                    right = mid;
                } else if (nums[mid] < target) {
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    right = mid; // 注意
                }
            }
            return left;
        }
        ```
        - 正确性：此时循环体判断条件为left < right, 因为right初始值为nums.length。搜索区间是[left, right)，左闭右开，所以left = mid + 1; right = mid;   
        - 为什么能找到左边界：这里重要的地方在于当nums[mid] == target时，不返回mid，而是令right = mid;可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。
    
    - 寻找 __右侧边界__ 的二分查找
        ```Java
        int right_bound(int[] nums, int target) {
            if (nums.length == 0) return -1;
            int left = 0, right = nums.length;
            
            while (left < right) {
                int mid = (left + right) / 2;
                if (nums[mid] == target) {
                    left = mid + 1; // 注意
                } else if (nums[mid] < target) {
                    left = mid + 1;
                } else if (nums[mid] > target) {
                    right = mid;
                }
            }
            return right - 1; // 注意
        }
        ```
        - 这里跟寻找左边界不同的是，当 nums[mid] == target 时，left = mid + 1。当找到target时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。
        - 因为收紧左侧边界时必须 left = mid + 1,所以最后无论返回 left 还是 right，必须减一
---

## 跳舞链


---

## 最大子序和 
LeetCode 53 动态规划：  
- 动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans
- 如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字
- 如果 sum <= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字
- 每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果
- 时间复杂度：O(n)

<div align="left">
<img src="./pics/53.png" width="500" align=center />
</div>
(图片摘自LeetCode题解)

---
## 质数计数 
LeetCode 204  
厄拉多塞筛法：  
- 选中数字2，并排除所有2的倍数
- 选中数字3，排除所有3的倍数
- 选中数字5，排除所有5的倍数
- 重复以上步骤
<div align="left">
<img src="./pics/204.png" width="500" align=center />
</div>
(图片摘自LeetCode题解)

---
## KMP 算法
http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html
- 构建部分匹配表，每个搜索词在表中对应的值为，从头开始到该词所构成的字符串，前后缀的共有元素的长度。
- 再从头开始做匹配，当发现有字符不匹配时，移动位数不是1了，改为：
    - 移动位数 = 已匹配的字符数 - 对应部分的匹配值

---


## LRU 缓存机制
LeetCode 146. 实现最近最少使用。核心在于使用哈希链表。以达成查找O(1) （哈希表的特性），增删也能O(1) （链表的特性）
<div align="left">
<img src="./pics/146.png" width="500" align=center />
</div>
(图片摘自LeetCode题解)


 <br><br>      

---

# 树相关算法

## 二叉树的遍历

1. __深度优先遍历__（通常是所指的是先序遍历）
    - 先序遍历  
        - 顺序：根左右
        - 迭代实现：使用栈，当前节点不为空时，输出该节点值并将其压入栈中，一直使用子循环一直将左子节点压入栈中，直到左子节点为空，再将当前栈顶节点弹出，去访问右子节点。
        ```Java
        // 递归先序遍历
        public static void recursionPreorderTraversal(TreeNode root) {
            if (root != null) {
                System.out.print(root.val + " ");
                recursionPreorderTraversal(root.left);
                recursionPreorderTraversal(root.right);
            }
        }
        ```
        ```Java
        // 非递归先序遍历
        public static void preorderTraversal(TreeNode root) {
            // 用来暂存节点的栈
            Stack<TreeNode> treeNodeStack = new Stack<TreeNode>();
            // 新建一个游标节点为根节点
            TreeNode node = root;
            // 当遍历到最后一个节点的时候，无论它的左右子树都为空，并且栈也为空
            // 所以，只要不同时满足这两点，都需要进入循环
            while (node != null || !treeNodeStack.isEmpty()) {
                // 若当前考查节点非空，则输出该节点的值
                // 由考查顺序得知，需要一直往左走
                while (node != null) {
                    System.out.print(node.val + " ");
                    // 为了之后能找到该节点的右子树，暂存该节点
                    treeNodeStack.push(node);
                    node = node.left;
                }
                // 一直到左子树为空，则开始考虑右子树
                // 如果栈已空，就不需要再考虑
                // 弹出栈顶元素，将游标等于该节点的右子树
                if (!treeNodeStack.isEmpty()) {
                    node = treeNodeStack.pop();
                    node = node.right;
                }
            }
        }
        ```
    - 中序遍历
        - 顺序：左根右
        - 迭代实现：与先序遍历相似，使用栈，唯一区别是使用子循环将左子节点压入栈时，不访问该节点，而是弹出时才访问。
        - __tips: 中序遍历二叉搜索树即为树中元素从小到大的顺序__，使用该方法可解决一系列BST问题。

        ```Java
        // 递归中序遍历
        public static void recursionMiddleorderTraversal(TreeNode root) {
            if (root != null) {
                recursionMiddleorderTraversal(root.left);
                System.out.print(root.val + " ");
                recursionMiddleorderTraversal(root.right);
            }
        }
        ```
        ```Java
        // 非递归中序遍历
        public static void middleorderTraversal(TreeNode root) {
            Stack<TreeNode> treeNodeStack = new Stack<TreeNode>();
            TreeNode node = root;
            while (node != null || !treeNodeStack.isEmpty()) {
                while (node != null) {
                    treeNodeStack.push(node);
                    node = node.left;
                }
                if (!treeNodeStack.isEmpty()) {
                    node = treeNodeStack.pop();
                    System.out.print(node.val + " ");
                    node = node.right;
                }
            }
        }
        ```

    - 后序遍历：
        - 顺序：左右根
        - 迭代实现：使用栈，在决定是否可以输出当前节点的值时，需要先判断左右子节点是否被访问过。所以需要设置一个额外的lastVisit游标。若lastVisit等于当前考查节点的右子树（或右子树为空），表示该节点的左右子树都已经遍历完成，则可以输出当前节点；否则，需要接着考虑右子树，node = node.right。
        ```Java
        // 递归后序遍历
        public static void recursionPostorderTraversal(TreeNode root) {
            if (root != null) {
                recursionPostorderTraversal(root.left);
                recursionPostorderTraversal(root.right);
                System.out.print(root.val + " ");
            }
        }
        ```
        ```Java
        // 非递归后序遍历
        public static void postorderTraversal(TreeNode root) {
            Stack<TreeNode> treeNodeStack = new Stack<TreeNode>();
            TreeNode node = root;
            TreeNode lastVisit = root;
            while (node != null || !treeNodeStack.isEmpty()) {
                while (node != null) {
                    treeNodeStack.push(node);
                    node = node.left;
                }
                //查看当前栈顶元素
                node = treeNodeStack.peek();
                //如果其右子树也为空，或者右子树已经访问
                //则可以直接输出当前节点的值
                if (node.right == null || node.right == lastVisit) {
                    System.out.print(node.val + " ");
                    treeNodeStack.pop();
                    lastVisit = node;
                    node = null;
                } else {
                    //否则，继续遍历右子树
                    node = node.right;
                }
            }
        }
        ```

2. __广度优先遍历__（层次遍历）
    - 使用队列实现。在队列中加入根节点，如果其左右子节点有不为空的，将根节点出队列，将左右子节点加入队列，以此循环直到队列为空即可。
    - 如需实现按层输出，可将每层节点暂存到数组中，按层遍历。或使用队列实现时，用字典存储节点的深度。

## Trie 前缀树
- 前缀树是一种字典树，每个节点中维护一个由\<子节点值, 子节点指针>键值对构成的字典。
- 查找时，从根节点开始逐字母读字符串，向下搜索即可。 

---
## 并查集





---
## 堆（优先队列）



<br><br>
---
# 图相关算法

## 拓扑排序  
1. 只能用在有向无环图上(DAG)
2. 原理：每次寻找一个入度为0的节点，访问该节点并删除所有以该节点为起点的有向边。如果剩下的节点中找不到入度为0的节点，说明该图存在环，不是一个DAG.

<br><br>
---
# 数学问题


## 鸡蛋掉落

https://juejin.im/post/5b98785de51d450e71250aab

- 基本问题： 100层楼，2个鸡蛋，最坏情况下，最多要试多少次？   答案：14次  
    x + (x-1) + (x-2) + \.\.\. + 1 = 100, 解得x = 14;
- 进阶问题： Leetcode 887 鸡蛋掉落，给定N层楼，K个鸡蛋，最少要试多少次？  
    - 动态规划，先将问题转换为：在最多x次尝试，有k个蛋的情况下，最坏时最多能测出多少层楼？
    - 状态转移方程： 
        - f(x, k) = f(x-1, k-1) + f(x-1, k) + 1;
        - (剩余x次，k个蛋可检测的楼层数) = (剩余x-1次，k-1个蛋可检测的层数) + (剩余x-1次，k个蛋可检测的层数) + 1;  即分为蛋碎了和没碎两种情况讨论.
    - 可以简化为黑箱子函数的返回值只跟鸡蛋个数k有关系:
        - 本次f(k) = 上次f(k-1)+上次f(k)+1

---
## 可怜的小猪
- LeetCode 458 数学类
- 基本问题：有 1000 只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在 15 分钟内死去。  
问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？
- 进阶问题：假设有 n 只水桶，猪饮水中毒后会在 m 分钟内死亡，你需要多少猪（x）就能在 p 分钟内找出 “有毒” 水桶？这 n 只水桶里有且仅有一只有毒的桶。  
- 思路：假设只有一轮实验，那么每只猪的状态只有两种，此时x只猪最多可以验证2^x个桶
- 推广：假设有n轮实验，那么每只猪的状态有(n+1)种，此时x只猪最多可验证(n+1)^x个桶，解方程(n+1)^x >= 桶数量即可  


---
## 快速竖式乘法

- LeetCode 43 字符串乘法，禁止使用大整数类
<div align="left">
<img src="./pics/43.png" width="500" align=center />
</div>
(图片摘自LeetCode题解)

--- 
## 超级次方
- LeetCode 372 计算a^b对1337取模，其中b是一个非常大的数
- 需要用到公式 (x*y)%k = (x%k)(y%k)%k
- 所以有：2^12345 % k = ((2^1234)^10 % k) * (2 ^ 5 % k) % k
- 递归计算即可

---
## 到达终点数字
LeetCode 754: 在一根无限长的数轴上，你站在0的位置。终点在target的位置。  
每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。  
返回到达终点需要的最小移动次数。  

    步数        能到达的位置  
    1:          1  
    2:          3, 1
    3:          6, 4, 2, 0
    4:          10, 8, 6, 4, 0
    5:          15, 13, 11, 9, 7, 5, 3, 1
    max(f(n)) = max(f(n-1)) + n
    f(n) = [max(f(n)),  max(f(n)) - 2, max(f(n)) - 4, ....]

    来源：力扣（LeetCode）

    思路，参照上表，如果target可以在第n步达到，那么target一定小于等于max(f(n))且max(f(n))与taget同奇同偶。
```cpp
int p = 0, i = 0;
while(p < target || (p + target) % 2 != 0){    //不是同奇同偶则不行，还要继续走
    i++;
    p = p + i;
}
```

---



